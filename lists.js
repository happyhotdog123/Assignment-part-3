
var rand = require('csprng')
var builder = require('xmlbuilder')
var mongo = require('./schema.js')

var lists = []

function validateJson(json) {
  if (typeof json.name !== 'string') {
    console.log('name not a string')
    return false
  }
  if (!Array.isArray(json.items)) {
    console.log('json.items is not an array')
    return false
  }
  for(var i=0; i<json.items.length; i++) {
    if (typeof json.items[i] !== 'string') {
      console.log('item ' + i + ' is not a string')
      return false
    }
  }
  return true
}

/* This public property contains a function that is passed a resource id and returns the associated list. */
exports.getByID = function(listID, callback) {
  console.log('getById: '+listID)
  mongo.List.findById(listID, function(err, data){
    if(err){
      callback({code: 400, response:{status:'error',contentType:'application/json', message:'ID not found', data: err}})
    } 
    callback({code: 200, response:{status:'success', message:'ID found', data: data}})
  })
  
  /* Here we loop through the lists. If we find one that matches the supplied id it is returned. */
      /* Note that every public method in this module returns an object with the same properties. This consistency makes the routes file simpler. */
  /* If there are no matching lists a 'resource not found' error is returned. */
 }

exports.getAll = function(host, callback) {
  console.log('getAll')
  mongo.List.find(function(err, data) {
    console.log('mongo list')
    if (err) {
      console.log('err: '+err)
      callback({code:400, response:{status:'error', contentType:'application/json', message:'lists found', data: err}})
    }
      callback ({code:200, response:{status:'success', message:'lists found', data: data}})
  } )
  
}

/* This is a sister property to 'getAll' but returns an XML representation instead. */
exports.getAllXML = function(host) {
  console.log('getAllXML')
  /* Here the xmlbuilder module is used to construct an XML document. */
  var xml = builder.create('root', {version: '1.0', encoding: 'UTF-8', standalone: true})
  /* If there are no lists in the array we build a single message node. */
  if (lists.length === 0) {
    xml.ele('message', {status: 'error'}, 'no lists found')
  } else {
    /* If there are lists we build a different message node. */
    xml.ele('message', {status: 'success'}, 'lists found')
    /* Then we create a 'lists' node which will be used to contain each list node. */
    var xmlLists = xml.ele('lists', {count: lists.length})
    /* We now loop through the lists, create a list node for each and add the details. */
    for(var i=0; i < lists.length; i++) {
      var list = xmlLists.ele('list', {id: lists[i].id})
      list.ele('name', lists[i].name)
      list.ele('link', {href:'http://'+host+'/lists/'+lists[i].id})
    }
  }
  /* Once the XML document is complete we call 'end()' to turn it into an XML string. */
  xml.end({pretty: true})
  /* There is a logical error in this code, can you spot it? */
  return {code: 200, contentType:'application/xml', response: xml}
}

/* This public property contains a function to add a new list to the module. */
exports.addNew = function(auth, body) {
  console.log('addNew')
  /* The first parameter should contain the authorization data. We check that it contains an object called 'basic' */
  /* In this simple example we have hard-coded the username and password. You should be storing this somewhere are looking it up. */
  /* The second parameter contains the request body as a 'string'. We need to turn this into a JavaScript object then pass it to a function to check its structure. */
  console.log(body)
  const json = JSON.parse(body)
   console.log(json)
  const valid = validateJson(json)
  /* If the 'validateJson()' function returns 'false' we need to return an error. */
  if (valid === false) {
    return {code: 400 ,contentType:'application/json', response:{ status:'error', message:'JSON data missing in request body' }}
  }
  /* In this example we use the csprng module to generate a long random string. In a production system this might be generated by the chosen data store. */
  //const newId = rand(160, 36)
  /* We now create an object and push it onto the array. */
  
  const newList = {username:json.username ,name:  json.name, items: json.items}
  mongo.addItem(newList)
  /* And return a success code. */
  return {code: 201, contentType:'application/json', response:{ status:'success', message:'new list added', data: newList }}
}

exports.update = function (auth, id, body, callback) {
  console.log('update')
  /* The first parameter should contain the authorization data. We check that it contains an object called 'basic' */
  /* In this simple example we have hard-coded the username and password. You should be storing this somewhere are looking it up. */



  const json = JSON.parse(body)

  const valid = validateJson(json)
  
    /* If the 'validateJson()' function returns 'false' we need to return an error. */
  if (valid === false) {
    callback({code: 400 ,response:{ status:'error', message:'JSON data missing in request body' }})
  }
  const newList = {username:json.username ,name:  json.name, items: json.items}
  
  
  /* The second parameter contains the request body as a 'string'. We need to turn this into a JavaScript object then pass it to a function to check its structure. */
  mongo.List.findByIdAndUpdate(id, {$set: newList}, {new: true}, function (err, updatedData){
    /*console.log('mongo update')
    if (err) {
      console.log('err: '+err)
      callback({code:400, response:{status:'error', contentType:'application/json', message:'item not found', data: err}})
    }
    callback({code: 201, contentType: 'application/json', data: updatedData})*/
  })
  return {code: 201, contentType:'application/json', response:{ status:'success', message:'new list added', data: 'dibe' }}
}